<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="RecyclerView 是 Android 5.0 提出的新 UI 控件，用来替代 ListView。 RecyclerView 官方定义如下：  A flexible view for providing a limited window into a large data set.">
<meta property="og:type" content="article">
<meta property="og:title" content="Android RecyclerView">
<meta property="og:url" content="http://example.com/2018/08/01/Android-RecyclerView/index.html">
<meta property="og:site_name" content="Vance 的博客">
<meta property="og:description" content="RecyclerView 是 Android 5.0 提出的新 UI 控件，用来替代 ListView。 RecyclerView 官方定义如下：  A flexible view for providing a limited window into a large data set.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://my-android.oss-cn-shanghai.aliyuncs.com/img/RecyclerView-Cache-Mechanism.png">
<meta property="og:image" content="https://my-android.oss-cn-shanghai.aliyuncs.com/img/RecyclerView-Cache-Mechanism2.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/186347/1613703158944-0557b978-36db-40f0-af64-a35f0b568202.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/186347/1613703276002-fdecc576-d1bd-4384-8a08-6b092944fb2b.png">
<meta property="article:published_time" content="2018-08-01T14:37:17.000Z">
<meta property="article:modified_time" content="2023-03-05T02:30:41.115Z">
<meta property="article:author" content="Vance">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="RecyclerView">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://my-android.oss-cn-shanghai.aliyuncs.com/img/RecyclerView-Cache-Mechanism.png">


<link rel="canonical" href="http://example.com/2018/08/01/Android-RecyclerView/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2018/08/01/Android-RecyclerView/","path":"2018/08/01/Android-RecyclerView/","title":"Android RecyclerView"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Android RecyclerView | Vance 的博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Vance 的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E7%B1%BB%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">重要类介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LayoutManager-%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">LayoutManager 布局管理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewHolder"><span class="nav-number">1.2.</span> <span class="nav-text">ViewHolder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Adapter"><span class="nav-number">1.3.</span> <span class="nav-text">Adapter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ItemAnimator-%E5%8A%A8%E7%94%BB"><span class="nav-number">1.4.</span> <span class="nav-text">ItemAnimator 动画</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ItemDecoration-%E8%A3%85%E9%A5%B0"><span class="nav-number">1.5.</span> <span class="nav-text">ItemDecoration 装饰</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-%E6%BB%91%E5%8A%A8%E5%88%A0%E9%99%A4%E5%92%8C%E6%8B%96%E6%8B%BD"><span class="nav-number">2.</span> <span class="nav-text">Item 滑动删除和拖拽</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">缓存机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RecyclerView-%E4%BC%98%E5%8C%96"><span class="nav-number">4.</span> <span class="nav-text">RecyclerView 优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%8F%96%E5%8A%9F%E8%83%BD-Prefetch"><span class="nav-number">4.1.</span> <span class="nav-text">预取功能 (Prefetch)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setHasFixedSize-true"><span class="nav-number">4.2.</span> <span class="nav-text">setHasFixedSize(true)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swapAdapter"><span class="nav-number">4.3.</span> <span class="nav-text">swapAdapter()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-ViewHolder-%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">4.4.</span> <span class="nav-text">获取 ViewHolder 的位置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RecyclerView-%E6%8B%93%E5%B1%95"><span class="nav-number">5.</span> <span class="nav-text">RecyclerView 拓展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0-Item-%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6"><span class="nav-number">5.1.</span> <span class="nav-text">添加 Item 点击事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0-HeaderView-%E5%92%8C-FooterView"><span class="nav-number">5.2.</span> <span class="nav-text">添加 HeaderView 和 FooterView</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0-EmptyView"><span class="nav-number">5.3.</span> <span class="nav-text">添加 EmptyView</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">5.4.</span> <span class="nav-text">嵌套滑动机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">6.</span> <span class="nav-text">遇到的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RecyclerView-%E5%B5%8C%E5%A5%97-ScrollView"><span class="nav-number">6.1.</span> <span class="nav-text">RecyclerView 嵌套 ScrollView</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CoordinatorLayout-AppBarLayout-RecyclerView%EF%BC%8C%E6%BB%9A%E5%8A%A8%E5%88%B0%E6%9C%80%E5%BA%95%E9%83%A8%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.</span> <span class="nav-text">CoordinatorLayout + AppBarLayout + RecyclerView，滚动到最底部延迟问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-lang-IllegalArgumentException-Called-attach-on-a-child-which-is-not-detached"><span class="nav-number">6.3.</span> <span class="nav-text">java.lang.IllegalArgumentException: Called attach on a child which is not detached</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">7.</span> <span class="nav-text">相关工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DiffUtil"><span class="nav-number">7.1.</span> <span class="nav-text">DiffUtil</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SortedList"><span class="nav-number">7.2.</span> <span class="nav-text">SortedList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncListUtil"><span class="nav-number">7.3.</span> <span class="nav-text">AsyncListUtil</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncListDiffer"><span class="nav-number">7.4.</span> <span class="nav-text">AsyncListDiffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SnapHelper"><span class="nav-number">7.5.</span> <span class="nav-text">SnapHelper</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Vance</p>
  <div class="site-description" itemprop="description">问道有先后，如是而已。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/01/Android-RecyclerView/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vance">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vance 的博客">
      <meta itemprop="description" content="问道有先后，如是而已。">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Android RecyclerView | Vance 的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android RecyclerView
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-01 22:37:17" itemprop="dateCreated datePublished" datetime="2018-08-01T22:37:17+08:00">2018-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>RecyclerView 是 Android 5.0 提出的新 UI 控件，用来替代 ListView。</p>
<p>RecyclerView 官方定义如下：</p>
<blockquote>
<p>A flexible view for providing a limited window into a large data set.</p>
</blockquote>
<span id="more"></span>
<h2 id="重要类介绍"><a href="#重要类介绍" class="headerlink" title="重要类介绍"></a>重要类介绍</h2><h3 id="LayoutManager-布局管理器"><a href="#LayoutManager-布局管理器" class="headerlink" title="LayoutManager 布局管理器"></a>LayoutManager 布局管理器</h3><p>LayoutManager 负责 RecyclerView 的布局。LayoutManager 是一个抽象类，SDK 实现有 <code>LinearLayoutManager</code> 、 <code>GridLayoutManager</code> 和 <code>StaggeredGridLayoutManager</code>，分别是线性布局、网格布局和瀑布流布局。</p>
<p>LayoutManager#onLayoutChildren() 是对 RecyclerView 进行布局的入口方法。LinearLayoutManager 的核心实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> &#123;</span><br><span class="line">    <span class="comment">//将原来所有的 ItemView 全部放到 Recycler 的 ScrapHeap 或 RecyclePool</span></span><br><span class="line">    detachAndScrapAttachedViews(recycler);</span><br><span class="line">    <span class="comment">// 填充现在所有的 ItemView</span></span><br><span class="line">    fill(recycler, mLayoutState, state, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对剩余空间不断地调用 layoutChunk()，直到填充完为止</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState,</span></span><br><span class="line"><span class="params">        RecyclerView.State state, <span class="type">boolean</span> stopOnFocusable)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">        layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span></span><br><span class="line"><span class="params">        LayoutState layoutState, LayoutChunkResult result)</span> &#123;</span><br><span class="line">    <span class="comment">//从缓存中获取 ItemView</span></span><br><span class="line">    <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> layoutState.next(recycler);</span><br><span class="line">    <span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">        addView(view);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addView(view, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//计算View的大小</span></span><br><span class="line">    <span class="comment">//计算 4 个边距</span></span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        <span class="comment">// 垂直排列</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 水平排列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知子 View 布局</span></span><br><span class="line">    layoutDecoratedWithMargins(view, left, top, right, bottom);<span class="comment">//布局View</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ViewHolder"><a href="#ViewHolder" class="headerlink" title="ViewHolder"></a>ViewHolder</h3><p>负责 itemView 中 childView 的管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">VH</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.ViewHolder &#123;</span><br><span class="line">    <span class="keyword">private</span> TextView mTextView;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VH</span><span class="params">(View itemView)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(itemView);</span><br><span class="line">        mTextView = (TextView) itemView.findViewById(android.R.id.text1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><p>负责创建视图并把指定位置上的数据填充到 View 上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Adapter</span>&lt;VH <span class="keyword">extends</span> <span class="title class_">ViewHolder</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>notifyDataSetChanged()</li>
<li>notifyItemChanged()&#x2F;notifyItemRangeChanged()</li>
<li>notifyItemInserted()&#x2F;notifyItemRangeInserted()</li>
<li>notifyItemMoved()&#x2F;notifyItemRangeRemoved()</li>
<li>notifyItemRangeChanged()</li>
</ul>
<h3 id="ItemAnimator-动画"><a href="#ItemAnimator-动画" class="headerlink" title="ItemAnimator 动画"></a>ItemAnimator 动画</h3><p>负责处理数据添加或者删除时的动画效果。<br><code>SimpleItemAnimator</code> 是 ItemAnimator 的子类，也是抽象类。<code>DefaultItemAnimator</code> 是 SimpleItemAnimator 的子类，是 SDK 提供的 RecycleView 默认动画。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecyclerView</span> &#123;</span><br><span class="line">    <span class="type">ItemAnimator</span> <span class="variable">mItemAnimator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultItemAnimator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Runnable</span> <span class="variable">mItemAnimatorRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//通过 runPendingAnimations() 方法执行动画</span></span><br><span class="line">            mItemAnimator.runPendingAnimations();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用动画 Runnable</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postAnimationRunner</span><span class="params">()</span> &#123;</span><br><span class="line">        ViewCompat.postOnAnimation(<span class="built_in">this</span>, mItemAnimatorRunner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setItemAnimator</span><span class="params">(ItemAnimator animator)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mItemAnimator != <span class="literal">null</span>) &#123;</span><br><span class="line">            mItemAnimator.endAnimations();</span><br><span class="line">            mItemAnimator.setListener(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mItemAnimator = animator;</span><br><span class="line">        <span class="keyword">if</span> (mItemAnimator != <span class="literal">null</span>) &#123;</span><br><span class="line">            mItemAnimator.setListener(mItemAnimatorListener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * This class defines the animations that take place on items as changes are made</span></span><br><span class="line"><span class="comment">    * to the adapter.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ItemAnimator</span> &#123;</span><br><span class="line">        <span class="comment">//当ViewHolder在屏幕上消失时被调用（可能是remove或move）</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">animateDisappearance</span><span class="params">(ViewHolder viewHolder,</span></span><br><span class="line"><span class="params">                ItemHolderInfo preLayoutInfo, ItemHolderInfo postLayoutInfo)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当ViewHolder在屏幕上出现时被调用（可能是add或move）</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">animateAppearance</span><span class="params">(ViewHolder viewHolder,</span></span><br><span class="line"><span class="params">                ItemHolderInfo preLayoutInfo, ItemHolderInfo postLayoutInfo)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在没调用notifyItemChanged()和notifyDataSetChanged()的情况下布局发生改变时被调用</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">animatePersistence</span><span class="params">(ViewHolder viewHolder,</span></span><br><span class="line"><span class="params">                ItemHolderInfo preLayoutInfo, ItemHolderInfo postLayoutInfo)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在显式调用notifyItemChanged()或notifyDataSetChanged()时被调用。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">animateChange</span><span class="params">(ViewHolder oldHolder, ViewHolder newHolder,</span></span><br><span class="line"><span class="params">                ItemHolderInfo preLayoutInfo, ItemHolderInfo postLayoutInfo)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*RecyclerView 动画的执行方式并不是立即执行，而是每帧执行一次。</span></span><br><span class="line"><span class="comment">        比如两帧之间添加了多个Item，则会将这些将要执行的动画保存在成员变量中，等到下一帧一起执行。</span></span><br><span class="line"><span class="comment">        该方法执行的前提是前面animateXxx()返回true。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">runPendingAnimations</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>RecyclerView 默认使用的是 DefaultItemAnimator 动画，也可以通过 setItemAnimator() 设置自定义动画。</li>
<li>ItemAnimator 是抽象类，定义了动画相关的抽象方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A wrapper class for ItemAnimator that records View bounds and decides whether it should run</span></span><br><span class="line"><span class="comment"> * move, change, add or remove animations. This class also replicates the original ItemAnimator</span></span><br><span class="line"><span class="comment"> * API.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It uses RecyclerView.ItemAnimator.ItemHolderInfo to track the bounds information of the Views. If you would like</span></span><br><span class="line"><span class="comment"> * to extend this class, you can override obtainHolderInfo() method to provide your own info</span></span><br><span class="line"><span class="comment"> * class that extends RecyclerView.ItemAnimator.ItemHolderInfo.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SimpleItemAnimator</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.ItemAnimator &#123;</span><br><span class="line">    <span class="comment">//当Item删除时被调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">animateRemove</span><span class="params">(RecyclerView.ViewHolder holder)</span>;</span><br><span class="line">    <span class="comment">//当Item添加时被调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">animateAdd</span><span class="params">(RecyclerView.ViewHolder holder)</span>;</span><br><span class="line">    <span class="comment">//当Item移动时被调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">animateMove</span><span class="params">(RecyclerView.ViewHolder holder, <span class="type">int</span> fromX, <span class="type">int</span> fromY, <span class="type">int</span> toX, <span class="type">int</span> toY)</span>;</span><br><span class="line">    <span class="comment">//当显式调用notifyItemChanged()或notifyDataSetChanged()时被调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">animateChange</span><span class="params">(RecyclerView.ViewHolder oldHolder,</span></span><br><span class="line"><span class="params">            RecyclerView.ViewHolder newHolder, <span class="type">int</span> fromLeft, <span class="type">int</span> fromTop, <span class="type">int</span> toLeft, <span class="type">int</span> toTop)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动画开始前需要调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">dispatchXxxStarting</span><span class="params">(RecyclerView.ViewHolder item)</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//动画结束后需要调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">dispatchXxxFinished</span><span class="params">(RecyclerView.ViewHolder item)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleItemAnimator 对 ItemAnimator 进行了封装，提供了更简洁、更容易理解的 Api。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultItemAnimator</span> <span class="keyword">extends</span> <span class="title class_">SimpleItemAnimator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">animateAdd</span><span class="params">(<span class="keyword">final</span> RecyclerView.ViewHolder holder)</span> &#123;</span><br><span class="line">        resetAnimation(holder);</span><br><span class="line">        holder.itemView.setAlpha(<span class="number">0</span>);</span><br><span class="line">        mPendingAdditions.add(holder);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">animateAddImpl</span><span class="params">(<span class="keyword">final</span> RecyclerView.ViewHolder holder)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> holder.itemView;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ViewPropertyAnimator</span> <span class="variable">animation</span> <span class="operator">=</span> view.animate();</span><br><span class="line">        mAddAnimations.add(holder);</span><br><span class="line">        animation.alpha(<span class="number">1</span>).setDuration(getAddDuration())</span><br><span class="line">                .setListener(<span class="keyword">new</span> <span class="title class_">AnimatorListenerAdapter</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationStart</span><span class="params">(Animator animator)</span> &#123;</span><br><span class="line">                        dispatchAddStarting(holder);<span class="comment">//动画开始前调用</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationCancel</span><span class="params">(Animator animator)</span> &#123;</span><br><span class="line">                        view.setAlpha(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationEnd</span><span class="params">(Animator animator)</span> &#123;</span><br><span class="line">                        animation.setListener(<span class="literal">null</span>);</span><br><span class="line">                        dispatchAddFinished(holder);<span class="comment">//动画结束后调用</span></span><br><span class="line">                        mAddAnimations.remove(holder);</span><br><span class="line">                        dispatchFinishedWhenDone();<span class="comment">//所有动画结束后回调，通知监听器</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runPendingAnimations</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. 判断 Pending 集合是否为空</span></span><br><span class="line"><span class="comment">        2. 执行 Remove 动画</span></span><br><span class="line"><span class="comment">        3. 同时执行 Move 和 Change 动画</span></span><br><span class="line"><span class="comment">        4. 执行 Add 动画</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// First, remove stuff</span></span><br><span class="line">        <span class="keyword">for</span> (RecyclerView.ViewHolder holder : mPendingRemovals) &#123;</span><br><span class="line">            animateRemoveImpl(holder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Next, move stuff</span></span><br><span class="line">        <span class="keyword">if</span> (movesPending) &#123;</span><br><span class="line">            <span class="comment">// 复制数据</span></span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;MoveInfo&gt; moves = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            moves.addAll(mPendingMoves);</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">mover</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (MoveInfo moveInfo : moves) &#123;</span><br><span class="line">                        animateMoveImpl(moveInfo.holder, moveInfo.fromX, moveInfo.fromY,</span><br><span class="line">                                moveInfo.toX, moveInfo.toY);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (removalsPending) &#123;</span><br><span class="line">                <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> moves.get(<span class="number">0</span>).holder.itemView;</span><br><span class="line">                ViewCompat.postOnAnimationDelayed(view, mover, getRemoveDuration());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mover.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Next, change stuff, to run in parallel with move animations</span></span><br><span class="line">        <span class="keyword">if</span> (changesPending) &#123;</span><br><span class="line">            <span class="comment">// 同 Move 动画类似</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Next, add stuff</span></span><br><span class="line">        <span class="keyword">if</span> (additionsPending) &#123;</span><br><span class="line">            <span class="keyword">if</span> (removalsPending || movesPending || changesPending) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">totalDelay</span> <span class="operator">=</span> removeDuration + Math.max(moveDuration, changeDuration);</span><br><span class="line">                <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> additions.get(<span class="number">0</span>).itemView;</span><br><span class="line">                <span class="comment">//等remove，move，change动画全部做完后，开始执行add动画</span></span><br><span class="line">                ViewCompat.postOnAnimationDelayed(view, adder, totalDelay);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                adder.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/wasabeef/recyclerview-animators">RecyclerView 动画三方库</a></p>
<h3 id="ItemDecoration-装饰"><a href="#ItemDecoration-装饰" class="headerlink" title="ItemDecoration 装饰"></a>ItemDecoration 装饰</h3><p>负责给 Item 添加额外的操作，例如画分隔线。ItemDecoration 可以添加多个，保存在集合中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LayoutParams</span> <span class="keyword">extends</span> <span class="title class_">android</span>.view.ViewGroup.MarginLayoutParams &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Rect</span> <span class="variable">mDecorInsets</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rect</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rect <span class="title function_">getItemDecorInsetsForChild</span><span class="params">(View child)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Rect</span> <span class="variable">insets</span> <span class="operator">=</span> lp.mDecorInsets;</span><br><span class="line">    insets.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">decorCount</span> <span class="operator">=</span> mItemDecorations.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; decorCount; i++) &#123;</span><br><span class="line">        mTempRect.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//重置 rect</span></span><br><span class="line">        <span class="comment">//inset 值保存到 mTempRect 中</span></span><br><span class="line">        mItemDecorations.get(i).getItemOffsets(mTempRect, child, <span class="built_in">this</span>, mState);</span><br><span class="line">        insets.left += mTempRect.left;</span><br><span class="line">        insets.top += mTempRect.top;</span><br><span class="line">        insets.right += mTempRect.right;</span><br><span class="line">        insets.bottom += mTempRect.bottom;</span><br><span class="line">    &#125;</span><br><span class="line">    lp.mInsetsDirty = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> insets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ItemDecoration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas c, RecyclerView parent, State state)</span> &#123;</span><br><span class="line">        <span class="comment">//绘制底层内容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDrawOver</span><span class="params">(Canvas c, RecyclerView parent, State state)</span> &#123;</span><br><span class="line">        <span class="comment">//绘制顶层内容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getItemOffsets</span><span class="params">(Rect outRect, View view, RecyclerView parent, State state)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 outRect 给 itemView 设置 insets。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layoutDecoratedWithMargins</span><span class="params">(View child, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Rect</span> <span class="variable">insets</span> <span class="operator">=</span> lp.mDecorInsets;</span><br><span class="line">    <span class="comment">//正值：ItemView 宽度变小，Item 之间有边距；负值：ItemView 宽度变大，Item 之间重合</span></span><br><span class="line">    child.layout(left + insets.left + lp.leftMargin, top + insets.top + lp.topMargin,</span><br><span class="line">            right - insets.right - lp.rightMargin,</span><br><span class="line">            bottom - insets.bottom - lp.bottomMargin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Canvas c)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.draw(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为是在 draw() 方法后，所以最后才绘制，显示在最顶层。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mItemDecorations.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 绘制顶层装饰</span></span><br><span class="line">        mItemDecorations.get(i).onDrawOver(c, <span class="built_in">this</span>, mState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas c)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 onDraw() -&gt; dispatchDraw(canvas) 绘制 child</span></span><br><span class="line">    <span class="built_in">super</span>.onDraw(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mItemDecorations.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 绘制底层装饰</span></span><br><span class="line">        mItemDecorations.get(i).onDraw(c, <span class="built_in">this</span>, mState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Item-滑动删除和拖拽"><a href="#Item-滑动删除和拖拽" class="headerlink" title="Item 滑动删除和拖拽"></a>Item 滑动删除和拖拽</h2><p>Android 提供了 <code>ItemTouchHelper</code> 类，使得 RecyclerView 能够轻易地实现滑动和拖拽。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is a utility class to add swipe to dismiss and drag &amp; drop support to RecyclerView.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemTouchHelper</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.ItemDecoration</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">RecyclerView</span>.OnChildAttachStateChangeListener &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认长按 Item 拖拽，可以通过此方法自定义拖拽功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startDrag</span><span class="params">(ViewHolder viewHolder)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    This class is the contract between ItemTouchHelper and your application.</span></span><br><span class="line"><span class="comment">    It lets you control which touch behaviors are enabled per each ViewHolder and</span></span><br><span class="line"><span class="comment">    also receive callbacks when user performs these actions.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置拖拽和滑动方向的标记</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getMovementFlags</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//拖拽回调</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">onMove</span><span class="params">(RecyclerView recyclerView, ViewHolder viewHolder, ViewHolder target)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//滑动回调</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">onSwiped</span><span class="params">(ViewHolder viewHolder, <span class="type">int</span> direction)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ViewHolder 状态改变回调。一共有三种状态：ACTION_STATE_IDLE、ACTION_STATE_SWIPE 和 ACTION_STATE_DRAG</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSelectedChanged</span><span class="params">(ViewHolder viewHolder, <span class="type">int</span> actionState)</span> &#123;</span><br><span class="line">            ItemTouchUIUtilImpl.INSTANCE.onSelected(viewHolder.itemView);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拖拽结束后回调</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearView</span><span class="params">(RecyclerView recyclerView, ViewHolder viewHolder)</span> &#123;</span><br><span class="line">            ItemTouchUIUtilImpl.INSTANCE.clearView(viewHolder.itemView);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLongPressDragEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleItemTouchCallback</span> <span class="keyword">extends</span> <span class="title class_">ItemTouchHelper</span>.Callback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyAdapter mAdapter;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ObjectModel&gt; mData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleItemTouchCallback</span><span class="params">(MyAdapter adapter, List&lt;ObjectModel&gt; data)</span> &#123;</span><br><span class="line">        mAdapter = adapter;</span><br><span class="line">        mData = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMovementFlags</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dragFlag</span> <span class="operator">=</span> ItemTouchHelper.UP | ItemTouchHelper.DOWN; <span class="comment">//上下拖拽</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">swipeFlag</span> <span class="operator">=</span> ItemTouchHelper.START | ItemTouchHelper.END; <span class="comment">//左右滑动</span></span><br><span class="line">        <span class="keyword">return</span> makeMovementFlags(dragFlag, swipeFlag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onMove</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> viewHolder.getAdapterPosition();</span><br><span class="line">        <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> target.getAdapterPosition();</span><br><span class="line">        Collections.swap(mData, from, to);</span><br><span class="line">        mAdapter.notifyItemMoved(from, to);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSwiped</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="type">int</span> direction)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> viewHolder.getAdapterPosition();</span><br><span class="line">        mData.remove(pos);</span><br><span class="line">        mAdapter.notifyItemRemoved(pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSelectedChanged</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="type">int</span> actionState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onSelectedChanged(viewHolder, actionState);</span><br><span class="line">        <span class="keyword">if</span> (actionState != ItemTouchHelper.ACTION_STATE_IDLE) &#123;</span><br><span class="line">            viewHolder.itemView.setBackgroundColor(Color.BLACK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearView</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.clearView(recyclerView, viewHolder);</span><br><span class="line">        viewHolder.itemView.setBackgroundColor(Color.White);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ItemTouchHelper</span> <span class="variable">itemTouchHelper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ItemTouchHelper</span>(<span class="keyword">new</span> <span class="title class_">SimpleItemTouchCallback</span>(adapter, data));</span><br><span class="line">itemTouchHelper.attachToRecyclerView(mRecyclerView);</span><br></pre></td></tr></table></figure>

<h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><p><img src="https://my-android.oss-cn-shanghai.aliyuncs.com/img/RecyclerView-Cache-Mechanism.png" alt="RecyclerView-Cache-Mechanism"><br><img src="https://my-android.oss-cn-shanghai.aliyuncs.com/img/RecyclerView-Cache-Mechanism2.png" alt="RecyclerView-Cache-Mechanism"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RecyclerView.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A Recycler is responsible for managing scrapped or detached item views for reuse.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* A &quot;scrapped&quot; view is a view that is still attached to its parent RecyclerView but</span></span><br><span class="line"><span class="comment">* that has been marked for removal or reuse.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Typical use of a Recycler by a LayoutManager will be to obtain views for</span></span><br><span class="line"><span class="comment">* an adapter&#x27;s data set representing the data at a given position or item ID.</span></span><br><span class="line"><span class="comment">* If the view to be reused is considered &quot;dirty&quot; the adapter will be asked to rebind it.</span></span><br><span class="line"><span class="comment">* If not, the view can be quickly reused by the LayoutManager with no further work.</span></span><br><span class="line"><span class="comment">* Clean views that have not requested layout</span></span><br><span class="line"><span class="comment">* may be repositioned by a LayoutManager without remeasurement.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Recycler</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mAttachedScrap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;ViewHolder&gt; mChangedScrap = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mCachedViews = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ViewHolder&gt;();</span><br><span class="line">    RecycledViewPool mRecyclerPool;</span><br><span class="line">    <span class="keyword">private</span> ViewCacheExtension mViewCacheExtension;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CACHE_SIZE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    ViewHolder <span class="title function_">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="type">int</span> position, <span class="type">boolean</span> dryRun, <span class="type">long</span> deadlineNs)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RecyclerView 缓存的是 RecyclerView.ViewHolder。内部实现了四级缓存:</p>
<ul>
<li><strong>mAttachedScrap 和 mChangedScrap</strong>：第一级缓存，用来保存被 RecycledView 移除掉但最近又马上要使用的缓存，比如说 RecycledView 中自带 item 的动画效果。</li>
<li><strong>mCachedViews</strong>：第二级缓存，缓存屏幕外的 ViewHolder，默认为 2 个。</li>
<li><strong>mViewCacheExtension</strong>： 第三级缓存，自定义的缓存，默认不实现。</li>
<li><strong>mRecyclerPool</strong>： 第四级缓存，缓存池，多个 RecyclerView 共用。</li>
</ul>
<p>LinearLayoutManager 在 <code>fill()</code> 方法中获取缓存的 ViewHolder 进行填充。具体方法是 <code>View view = layoutState.next(recycler)</code> 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LayoutState</span> &#123;</span><br><span class="line">    View <span class="title function_">next</span><span class="params">(RecyclerView.Recycler recycler)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> recycler.getViewForPosition(mCurrentPosition);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Recycler</span> &#123;</span><br><span class="line">    View <span class="title function_">getViewForPosition</span><span class="params">(<span class="type">int</span> position, <span class="type">boolean</span> dryRun)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ViewHolder <span class="title function_">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="type">int</span> position, <span class="type">boolean</span> dryRun, <span class="type">long</span> deadlineNs)</span> &#123;</span><br><span class="line">        <span class="type">ViewHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//1. 从 mAttachedScrap, mCachedViews 中获取</span></span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">            holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class="line">        ｝</span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">            <span class="comment">//默认为false</span></span><br><span class="line">            <span class="keyword">if</span> (mAdapter.hasStableIds()) &#123;</span><br><span class="line">                holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);</span><br><span class="line">            ｝</span><br><span class="line">        ｝</span><br><span class="line">        <span class="comment">//2. 从 ViewCacheExtention 获取，默认不实现</span></span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="literal">null</span> &amp;&amp; mViewCacheExtension != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> mViewCacheExtension .getViewForPositionAndType(<span class="built_in">this</span>, position, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 从 RecycledViewPool 中获取</span></span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">            holder = getRecycledViewPool().getRecycledView(type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4. 最后通过 Adapter 创建 ViewHolder</span></span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">            holder = mAdapter.createViewHolder(RecyclerView.<span class="built_in">this</span>, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">            tryBindViewHolderByDeadline(...)</span><br><span class="line">        ｝</span><br><span class="line">    ｝</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryBindViewHolderByDeadline</span><span class="params">(...)</span>&#123;</span><br><span class="line">        mAdapter.bindViewHolder(holder, offsetPosition);</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>从上述实现可以看出，依次从 mAttachedScrap, mCachedViews, mViewCacheExtension, mRecyclerPool 中寻找可复用的 ViewHolder。</p>
<ol>
<li>如果是从 mAttachedScrap 或 mCachedViews 中获取的 ViewHolder，则不会调用 onCreateViewHolder()创建方法，只会调用onBindViewHolder()绑定数据。</li>
<li>如果从 mViewCacheExtension 或 mRecyclerPool 中获取的 ViewHolder，则会调用 onBindViewHolder()。</li>
</ol>
<ul>
<li><strong>mAttachedScrap</strong>： 不参与滑动时的回收复用，只保存重新布局时从RecyclerView分离的item的无效、未移除、未更新的holder。因为RecyclerView在onLayout的时候，会先把children全部移除掉，再重新添加进入，mAttachedScrap临时保存这些holder复用。</li>
<li><strong>mChangedScrap</strong>： mChangedScrap和mAttachedScrap类似，不参与滑动时的回收复用，只是用作临时保存的变量，它只会负责保存重新布局时发生变化的item的无效、未移除的holder，那么会重走adapter绑定数据的方法。</li>
<li><strong>mCachedViews</strong>： 用于保存最新被移除(remove)的ViewHolder，已经和RecyclerView分离的视图；它的作用是滚动的回收复用时如果需要新的ViewHolder时，精准匹配(根据position&#x2F;id判断)是不是原来被移除的那个item；如果是，则直接返回ViewHolder使用，不需要重新绑定数据；如果不是则不返回，再去mRecyclerPool中找holder实例返回，并重新绑定数据。这一级的缓存是有容量限制的，最大数量为2。</li>
<li><strong>mViewCacheExtension</strong>： RecyclerView给开发者预留的缓存池，开发者可以自己拓展回收池，一般不会用到，用RecyclerView系统自带的已经足够了。</li>
<li><strong>mRecyclerPool</strong>： 是一个终极回收站，真正存放着被标识废弃(其他池都不愿意回收)的ViewHolder的缓存池，如果上述mAttachedScrap、mChangedScrap、mCachedViews、mViewCacheExtension都找不到ViewHolder的情况下，就会从mRecyclerPool返回一个废弃的ViewHolder实例，但是这里的ViewHolder是已经被抹除数据的，没有任何绑定的痕迹，需要重新绑定数据。它是根据itemType来存储的，是以SparseArray嵌套一个ArraryList的形式保存ViewHolder的。</li>
</ul>
<p><strong>ListView 缓存机制：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/186347/1613703158944-0557b978-36db-40f0-af64-a35f0b568202.png" alt="ListView 缓存"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/186347/1613703276002-fdecc576-d1bd-4384-8a08-6b092944fb2b.png" alt="RecyclerView 缓存"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbsListView</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    The RecycleBin facilitates reuse of views across layouts.</span></span><br><span class="line"><span class="comment">    The RecycleBin has two levels of storage: ActiveViews and ScrapViews.</span></span><br><span class="line"><span class="comment">    ActiveViews are those views which were onscreen at the start of a layout. By construction, they are displaying current information.</span></span><br><span class="line"><span class="comment">    At the end of layout, all views in ActiveViews are demoted to ScrapViews.</span></span><br><span class="line"><span class="comment">    ScrapViews are old views that could potentially be used by the adapter to avoid allocating views unnecessarily.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">RecycleBin</span> &#123;</span><br><span class="line">        <span class="comment">//存储屏幕上的View</span></span><br><span class="line">        <span class="keyword">private</span> View[] mActiveViews = <span class="keyword">new</span> <span class="title class_">View</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//每类 ViewType 对应一个 ArrayList</span></span><br><span class="line">        <span class="keyword">private</span> ArrayList&lt;View&gt;[] mScrapViews;</span><br><span class="line">        <span class="comment">//ViewType 的数量为 1 时的集合</span></span><br><span class="line">        <span class="keyword">private</span> ArrayList&lt;View&gt; mCurrentScrap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">addScrapView</span><span class="params">(View scrap, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> AbsListView.<span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (AbsListView.LayoutParams) scrap.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewType</span> <span class="operator">=</span> lp.viewType;</span><br><span class="line">            <span class="keyword">if</span> (mViewTypeCount == <span class="number">1</span>) &#123;</span><br><span class="line">                mCurrentScrap.add(scrap);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mScrapViews[viewType].add(scrap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> A view from the ScrapViews collection. These are unordered.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        View <span class="title function_">getScrapView</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">whichScrap</span> <span class="operator">=</span> mAdapter.getItemViewType(position);</span><br><span class="line">            <span class="keyword">if</span> (whichScrap &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mViewTypeCount == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> retrieveFromScrap(mCurrentScrap, position);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (whichScrap &lt; mScrapViews.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> retrieveFromScrap(mScrapViews[whichScrap], position);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从回收列表中取出最后一个元素复用</span></span><br><span class="line">        <span class="keyword">private</span> View <span class="title function_">retrieveFromScrap</span><span class="params">(ArrayList&lt;View&gt; scrapViews, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> scrapViews.size();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">scrap</span> <span class="operator">=</span> scrapViews.remove(size - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> scrap;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Move all views remaining in mActiveViews to mScrapViews.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">scrapActiveViews</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">        View <span class="title function_">getActiveView</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> position - mFirstActivePosition;</span><br><span class="line">            <span class="keyword">final</span> View[] activeViews = mActiveViews;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;=<span class="number">0</span> &amp;&amp; index &lt; activeViews.length) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">match</span> <span class="operator">=</span> activeViews[index];</span><br><span class="line">                activeViews[index] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span> match;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Subclasses must override this method to layout their children.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">layoutChildren</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    View <span class="title function_">obtainView</span><span class="params">(<span class="type">int</span> position, <span class="type">boolean</span>[] outMetadata)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">scrapView</span> <span class="operator">=</span> mRecycler.getScrapView(position);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> mAdapter.getView(position, scrapView, <span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListView</span> <span class="keyword">extends</span> <span class="title class_">AbsListView</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">layoutChildren</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果数据被改变了，则将所有 ItemView 回收至 scrapView</span></span><br><span class="line">        <span class="keyword">if</span> (dataChanged) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">                recycleBin.addScrapView(getChildAt(i), firstPosition+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            recycleBin.fillActiveViews(childCount, firstPosition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据 mLayoutMode 执行不同的填充 fillXxx() 方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//回收多余的activeView</span></span><br><span class="line">        mRecycler.scrapActiveViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> View <span class="title function_">fillSpecific</span><span class="params">(<span class="type">int</span> position, <span class="type">int</span> top)</span> &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">temp</span> <span class="operator">=</span> makeAndAddView(position, top, <span class="literal">true</span>, mListPadding.left, tempIsSelected);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> View <span class="title function_">makeAndAddView</span><span class="params">(<span class="type">int</span> position, <span class="type">int</span> y, <span class="type">boolean</span> flow, <span class="type">int</span> childrenLeft, <span class="type">boolean</span> selected)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mDataChanged) &#123;</span><br><span class="line">            <span class="comment">// Try to use an existing view for this position.</span></span><br><span class="line">            <span class="comment">//可以直接复用指定位置的 View</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">activeView</span> <span class="operator">=</span> mRecycler.getActiveView(position);</span><br><span class="line">            <span class="keyword">if</span> (activeView != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Found it. We&#x27;re reusing an existing child, so it just needs</span></span><br><span class="line">                <span class="comment">// to be positioned like a scrap view.</span></span><br><span class="line">                setupChild(activeView, position, y, flow, childrenLeft, selected, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> activeView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make a new view for this position, or convert an unused view if</span></span><br><span class="line">        <span class="comment">// possible.</span></span><br><span class="line">        <span class="comment">//从缓存或 Adapter 获取</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> obtainView(position, mIsScrap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This needs to be positioned and measured.</span></span><br><span class="line">        setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ListView 和 RecyclerView 缓存机制基本一致：</p>
<ol>
<li>mActiveViews 和 mAttachedScrap 功能相似，意义在于快速重用屏幕上可见的 ItemView，而不需要重新 createView 和 bindView；</li>
<li>mScrapView 和 mCachedViews + mReyclerViewPool 功能相似，意义在于缓存离开屏幕的 ItemView，目的是让即将进入屏幕的 ItemView 重用；</li>
<li>RecyclerView 的优势在于:<ul>
<li>mCacheViews 的使用，可以做到屏幕外的列表项 ItemView 进入屏幕内时也无须 bindView 快速重用；</li>
<li>mRecyclerPool 可以供多个 RecyclerView 共同使用。在特定场景下，如 viewpaper+多个列表页下有优势.客观来说，RecyclerView 在特定场景下对 ListView 的缓存机制做了补强和完善。</li>
</ul>
</li>
</ol>
<h2 id="RecyclerView-优化"><a href="#RecyclerView-优化" class="headerlink" title="RecyclerView 优化"></a>RecyclerView 优化</h2><h3 id="预取功能-Prefetch"><a href="#预取功能-Prefetch" class="headerlink" title="预取功能 (Prefetch)"></a>预取功能 (Prefetch)</h3><p>为了充分利用 CPU，当 CPU 空闲时 RecyclerView 会预取接下来可能要显示的 item，在下一帧到来之前提前处理完数据，然后将得到的 itemholder 缓存起来，等到真正要使用的时候直接从缓存取出来即可。</p>
<p><code>LinearLayoutManager#setInitialPrefetchItemCount(int itemCount)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RecycledView.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent e)</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            <span class="keyword">if</span> (mScrollState == SCROLL_STATE_DRAGGING) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mGapWorker != <span class="literal">null</span> &amp;&amp; (dx != <span class="number">0</span> || dy != <span class="number">0</span>)) &#123;</span><br><span class="line">                    mGapWorker.postFromTraversal(<span class="built_in">this</span>, dx, dy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据创建同类型的 ViewHolder 所需要的时间来判断。</p>
<h3 id="setHasFixedSize-true"><a href="#setHasFixedSize-true" class="headerlink" title="setHasFixedSize(true)"></a>setHasFixedSize(true)</h3><p>RecyclerView 的大小不会因数据集的更新而改变时设置为 ture, 当添加和删除 item 时不会重新 requestLayout()。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/28709220/understanding-recyclerview-sethasfixedsize">stackoverflow</a> 回答如下：</p>
<blockquote>
<p>RecyclerView size changes every time you add something no matter what. What setHasFixedSize does is that it makes sure (by user input) that this change of size of RecyclerView is constant. The height (or width) of the item won’t change. Every item added or removed will be the same. If you dont set this it will check if the size of the item has changed and thats expensive. Just clarifying because this answer is confusing. – ArnoldB May 25 at 18:42</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* RecyclerView can perform several optimizations if it can know in advance that RecyclerView&#x27;s</span></span><br><span class="line"><span class="comment">* size is not affected by the adapter contents. RecyclerView can still change its size based</span></span><br><span class="line"><span class="comment">* on other factors (e.g. its parent&#x27;s size) but this size calculation cannot depend on the</span></span><br><span class="line"><span class="comment">* size of its children or contents of its adapter (except the number of items in the adapter).</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* If your use of RecyclerView falls into this category, set this to &#123;<span class="doctag">@code</span> true&#125;. It will allow</span></span><br><span class="line"><span class="comment">* RecyclerView to avoid invalidating the whole layout when its adapter contents change.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> hasFixedSize true if adapter changes cannot affect the size of the RecyclerView.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHasFixedSize</span><span class="params">(<span class="type">boolean</span> hasFixedSize)</span> &#123;</span><br><span class="line">  mHasFixedSize = hasFixedSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecyclerView</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthSpec, <span class="type">int</span> heightSpec)</span> &#123;</span><br><span class="line">        <span class="comment">// LinearLayoutManager GridLayoutManager 重写为 true</span></span><br><span class="line">        <span class="keyword">if</span> (mLayout.isAutoMeasureEnabled()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mHasFixedSize) &#123;</span><br><span class="line">                mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">RecyclerViewDataObserver</span> <span class="keyword">extends</span> <span class="title class_">AdapterDataObserver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">()</span> &#123;</span><br><span class="line">        requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onItemRangeXXX</span><span class="params">(<span class="type">int</span> positionStart, <span class="type">int</span> itemCount, Object payload)</span> &#123;</span><br><span class="line">        triggerUpdateProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">triggerUpdateProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// &gt;= 4.1 &amp;&amp; mHasFixedSize 为 true &amp;&amp; RecyclerView attach 到 Window</span></span><br><span class="line">        <span class="keyword">if</span> (POST_UPDATES_ON_ANIMATION &amp;&amp; mHasFixedSize &amp;&amp; mIsAttached) &#123;</span><br><span class="line">            ViewCompat.postOnAnimation(RecyclerView.<span class="built_in">this</span>, mUpdateChildViewsRunnable);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="swapAdapter"><a href="#swapAdapter" class="headerlink" title="swapAdapter()"></a>swapAdapter()</h3><p>setAdapter() 会直接清空 RecycledView 上的所有缓存，而 swapAdapter() 会重用 ViewHolder，而且不会清空 RecycledViewPool。适用于两个数据集大致相同的情况。</p>
<h3 id="获取-ViewHolder-的位置"><a href="#获取-ViewHolder-的位置" class="headerlink" title="获取 ViewHolder 的位置"></a>获取 ViewHolder 的位置</h3><ul>
<li>findViewHolderForPosition()</li>
<li>findViewHolderForAdapterPosition()</li>
<li>findViewHolderForLayoutPosition()</li>
</ul>
<h2 id="RecyclerView-拓展"><a href="#RecyclerView-拓展" class="headerlink" title="RecyclerView 拓展"></a>RecyclerView 拓展</h2><h3 id="添加-Item-点击事件"><a href="#添加-Item-点击事件" class="headerlink" title="添加 Item 点击事件"></a>添加 Item 点击事件</h3><h3 id="添加-HeaderView-和-FooterView"><a href="#添加-HeaderView-和-FooterView" class="headerlink" title="添加 HeaderView 和 FooterView"></a>添加 HeaderView 和 FooterView</h3><h3 id="添加-EmptyView"><a href="#添加-EmptyView" class="headerlink" title="添加 EmptyView"></a>添加 EmptyView</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmptyRecyclerView</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RecyclerView.<span class="type">AdapterDataObserver</span> <span class="variable">mObserver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RecyclerView</span>.AdapterDataObserver() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">()</span> &#123;</span><br><span class="line">            RecyclerView.<span class="type">Adapter</span> <span class="variable">adapter</span> <span class="operator">=</span> mRecyclerView.getAdapter();</span><br><span class="line">            <span class="keyword">if</span> (adapter.getItemCount() == <span class="number">0</span>) &#123;</span><br><span class="line">                mEmptyView.setVisibility(View.VISIBLE);</span><br><span class="line">                setVisibility(View.GONE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mEmptyView.setVisibility(View.GONE);</span><br><span class="line">                setVisibility(View.VISIBLE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAdapter</span><span class="params">(RecyclerView.Adapter adapter)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.setAdapter(adapter);</span><br><span class="line">        adapter.registerAdapterDataObserver(mObserver);</span><br><span class="line">        mObserver.onChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmptyView</span><span class="params">(View view)</span>&#123;</span><br><span class="line">        mEmptyView = view;</span><br><span class="line">        ((ViewGroup)getRootView()).addView(mEmptyView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="嵌套滑动机制"><a href="#嵌套滑动机制" class="headerlink" title="嵌套滑动机制"></a>嵌套滑动机制</h3><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="RecyclerView-嵌套-ScrollView"><a href="#RecyclerView-嵌套-ScrollView" class="headerlink" title="RecyclerView 嵌套 ScrollView"></a>RecyclerView 嵌套 ScrollView</h3><p><strong>滑动冲突:</strong></p>
<ol>
<li>ScrollView 换成 NestedScrollView；</li>
<li>设置 RecyclerView#setNestedScrollingEnabled(false);</li>
</ol>
<p><strong>RecyclerView#setHasFixedSize(boolean hasFixedSize):</strong></p>
<ul>
<li><p>不嵌套 NestedScrollView<br> 不管设置 true 或 false 都会根据屏幕显示进行渲染。</p>
</li>
<li><p>嵌套 NestedScrollView</p>
<ol>
<li>不管设置 true 或 false 都会渲染全部数据。</li>
<li><code>RecyclerView.ViewHolder 无法复用。</code></li>
</ol>
</li>
</ul>
<p><strong>notifyDataSetChanged() 和 notifyItemInserted():</strong></p>
<ul>
<li>notifyDataSetChanged() 会渲染整个数据集。</li>
<li>notifyItemInserted() 不嵌套 NestedScrollView 时，在屏幕内才渲染。嵌套 NestedScrollView 时，添加数据时就会渲染，不管新添加的数据在不在屏幕内。但是滑动到屏幕内时就不再渲染了。</li>
<li>当 Adapter 添加新数据时 notifyDataSetChanged() 会创建新的 ViewHolder，而 notifyItemInserted() 不会</li>
</ul>
<p><strong>notifyItemInserted() 不显示数据问题:</strong></p>
<p>设置 RecyclerView#setHasFixedSize(false)，重新测量 RecyclerView 的大小。</p>
<p><strong>RecyclerView.OnScrollListener 不回调问题:</strong></p>
<ol>
<li>ScrollView 和 RecycleView 都是垂直方向<ul>
<li>如果 RecyclerView.setNestedScrollingEnabled(false)，RecyclerView.OnScrollListener 接收不到通知。</li>
<li>如果 RecyclerView.setNestedScrollingEnabled(true)，onScrolled() 只回调一次，onScrollStateChanged() 在一定方向上每次会回调一次，但是再反向滚动回去就不会回调了。</li>
</ul>
</li>
<li>ScrollView 垂直方向， RecycleView 横向。没有问题.</li>
<li>HorizontalScrollView（横向）嵌套 RecyclerView（横向），RecycleView 不能滚动。</li>
</ol>
<h3 id="CoordinatorLayout-AppBarLayout-RecyclerView，滚动到最底部延迟问题"><a href="#CoordinatorLayout-AppBarLayout-RecyclerView，滚动到最底部延迟问题" class="headerlink" title="CoordinatorLayout + AppBarLayout + RecyclerView，滚动到最底部延迟问题"></a>CoordinatorLayout + AppBarLayout + RecyclerView，滚动到最底部延迟问题</h3><p>material 包从某个升级引入了惯性下滑的概念。滑动的速度越快，下滑的时间越长，就会导致 RecyclerView 实际上已经滑动到最底部了，但是还是卡在了下滑的过程之中，等惯性下滑的触发结束以后，才会触发 RecyclerView#onScrollStateChanged()。<br>用户体验上就是 RecyclerView 明明已经滑动到最底部，应该显示加载中去获取下一页数据了，却一直卡着不动。需要等一小会才加载数据。</p>
<p>解决方法是自定义一个 behavior 类继承 AppBarLayout.Behavior，加速结束惯性下滑的回调，当滑动到顶部或到底就认为滑动结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScrollAppBarLayoutBehavior</span> <span class="keyword">extends</span> <span class="title class_">AppBarLayout</span>.Behavior &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScrollAppBarLayoutBehavior</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNestedPreScroll</span><span class="params">(CoordinatorLayout coordinatorLayout, AppBarLayout child,</span></span><br><span class="line"><span class="params">                                  View target, <span class="type">int</span> dx, <span class="type">int</span> dy, <span class="type">int</span>[] consumed, <span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed, type);</span><br><span class="line">        stopNestedScrollIfNeeded(dy, child, target, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNestedScroll</span><span class="params">(CoordinatorLayout coordinatorLayout, AppBarLayout child, View target,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> dxConsumed, <span class="type">int</span> dyConsumed, <span class="type">int</span> dxUnconsumed, <span class="type">int</span> dyUnconsumed, <span class="type">int</span> type, <span class="type">int</span>[] consumed)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, type, consumed);</span><br><span class="line">        stopNestedScrollIfNeeded(dyUnconsumed, child, target, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stopNestedScrollIfNeeded</span><span class="params">(<span class="type">int</span> dy, AppBarLayout child, View target, <span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == ViewCompat.TYPE_NON_TOUCH) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">currOffset</span> <span class="operator">=</span> getTopAndBottomOffset();</span><br><span class="line">            <span class="keyword">if</span> ((dy &lt; <span class="number">0</span> &amp;&amp; currOffset == <span class="number">0</span>) || (dy &gt; <span class="number">0</span> &amp;&amp; currOffset == -child.getTotalScrollRange())) &#123;</span><br><span class="line">                ViewCompat.stopNestedScroll(target, ViewCompat.TYPE_NON_TOUCH);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java-lang-IllegalArgumentException-Called-attach-on-a-child-which-is-not-detached"><a href="#java-lang-IllegalArgumentException-Called-attach-on-a-child-which-is-not-detached" class="headerlink" title="java.lang.IllegalArgumentException: Called attach on a child which is not detached"></a>java.lang.IllegalArgumentException: Called attach on a child which is not detached</h3><p>报错日志如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: Called attach on a child which is not detached: c419ef6e position=11 id=-1, oldPos=-1, pLpos:-1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>出现这个问题的原因是更新了不在屏幕中显示的 item。操作的这个 ViewHolder 当前不是被绑定的，因为 RecyclerView 有缓存机制，未在屏幕上显示的 item 会被暂时回收，即 detached。</p>
<p>出现这个问题的原因是更新了不在屏幕中显示的 item。解决办法是判断要更新的 item 是不是在屏幕中，判断方法是获取 RecyclerView 的 LayoutManager，前提是 RecyclerView 设置的 LayoutManager 是 LinearLayoutManager。获取第一个可见位置和最后一个可见位置的 position，判断当前要更新的 item 的 position 在这个范围内才更新。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RecyclerView.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attachViewToParent</span><span class="params">(View child, <span class="type">int</span> index,</span></span><br><span class="line"><span class="params">        ViewGroup.LayoutParams layoutParams)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ViewHolder</span> <span class="variable">vh</span> <span class="operator">=</span> getChildViewHolderInt(child);</span><br><span class="line">    <span class="keyword">if</span> (vh != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vh.isTmpDetached() &amp;&amp; !vh.shouldIgnore()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Called attach on a child which is not&quot;</span></span><br><span class="line">                    + <span class="string">&quot; detached: &quot;</span> + vh + exceptionLabel());</span><br><span class="line">        &#125;</span><br><span class="line">        vh.clearTmpDetachFlag();</span><br><span class="line">    &#125;</span><br><span class="line">    RecyclerView.<span class="built_in">this</span>.attachViewToParent(child, index, layoutParams);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detachViewFromParent</span><span class="params">(<span class="type">int</span> offset)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> getChildAt(offset);</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ViewHolder</span> <span class="variable">vh</span> <span class="operator">=</span> getChildViewHolderInt(view);</span><br><span class="line">        <span class="keyword">if</span> (vh != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vh.isTmpDetached() &amp;&amp; !vh.shouldIgnore()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;called detach on an already&quot;</span></span><br><span class="line">                        + <span class="string">&quot; detached child &quot;</span> + vh + exceptionLabel());</span><br><span class="line">            &#125;</span><br><span class="line">            vh.addFlags(ViewHolder.FLAG_TMP_DETACHED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RecyclerView.<span class="built_in">this</span>.detachViewFromParent(offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相关工具类"><a href="#相关工具类" class="headerlink" title="相关工具类"></a>相关工具类</h2><h3 id="DiffUtil"><a href="#DiffUtil" class="headerlink" title="DiffUtil"></a>DiffUtil</h3><h3 id="SortedList"><a href="#SortedList" class="headerlink" title="SortedList"></a>SortedList</h3><p>适用于列表有序的场景（城市列表页，中文首字母排序）。并且 SortedList 会帮助你比较数据的差异，定向刷新数据，而不是简单粗暴的 notifyDataSetChanged()。</p>
<h3 id="AsyncListUtil"><a href="#AsyncListUtil" class="headerlink" title="AsyncListUtil"></a>AsyncListUtil</h3><p>用于异步加载数据，我们无需在 UI 线程上查询游标，同时它可以保持 UI 和缓存同步，并且始终只在内存中保留有限数量的数据。使用它可以获得更好的用户体验。<br>这个类使用单线程来加载数据，因此它适合从磁盘、数据库加载数据，不适用于从网络加载数据。</p>
<h3 id="AsyncListDiffer"><a href="#AsyncListDiffer" class="headerlink" title="AsyncListDiffer"></a>AsyncListDiffer</h3><h3 id="SnapHelper"><a href="#SnapHelper" class="headerlink" title="SnapHelper"></a>SnapHelper</h3><p>用于辅助 RecyclerView 在滚动结束时将 Item 对齐到某个位置。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://developer.android.com/reference/kotlin/androidx/recyclerview/widget/RecyclerView">[1] Developer Docs</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/23339185">[2] 【腾讯 Bugly 干货分享】Android ListView 与 RecyclerView 对比浅析—缓存机制</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/CzrKotyupXbYY6EY2HP_dA">[3] 腾讯 BuglyRecyclerView 必知必会</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
              <a href="/tags/RecyclerView/" rel="tag"># RecyclerView</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/07/10/Java-%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/" rel="prev" title="Java 注解处理器">
                  <i class="fa fa-chevron-left"></i> Java 注解处理器
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/08/16/Android-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/" rel="next" title="Android 架构模式">
                  Android 架构模式 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vance</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
